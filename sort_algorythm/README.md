## 1. バブルソート (Bubble Sort)

### **問題**
配列を昇順にソートする。

### **アルゴリズム**
1. 隣接する要素を比較し、必要に応じて交換。
2. 配列全体を通して交換が発生しなくなるまで繰り返す。

### **計算量**
- **最悪ケース**: \( O(n^2) \)  
  配列が逆順の場合、全ての要素を何度も比較・交換する必要がある。
- **最良ケース**: \( O(n) \)  
  配列がすでにソート済みの場合。

---

## 2. 挿入ソート (Insertion Sort)

### **問題**
配列を昇順にソートする。

### **アルゴリズム**
1. 配列を左から順に取り出し、ソート済み部分に挿入。
2. 挿入位置を決定するためにソート済み部分を逆方向に走査。

### **計算量**
- **最悪ケース**: \( O(n^2) \)  
  配列が逆順の場合、すべての要素を比較・シフトする必要がある。
- **最良ケース**: \( O(n) \)  
  配列がすでにソート済みの場合。

---

## 3. 選択ソート (Selection Sort)

### **問題**
配列を昇順にソートする。

### **アルゴリズム**
1. 未ソート部分から最小値を見つけ、ソート済み部分の末尾と交換。
2. 未ソート部分を縮小しながら繰り返す。

### **計算量**
- **最悪ケース**: \( O(n^2) \)  
  各要素に対して残りのすべての要素を比較する必要がある。
- **最良ケース**: \( O(n^2) \)  
  配列の順序に関わらず、すべての要素を比較する必要がある。

---

## 4. クイックソート (Quick Sort)

### **問題**
配列を昇順にソートする。

### **アルゴリズム**
1. 配列の中から1つの要素をピボットとして選ぶ。
2. ピボットより小さい要素を左、大きい要素を右に分ける。
3. 左右の部分を再帰的にソート。
4. 最終的にピボットと左右のソート済み部分を結合する。

### **計算量**
- **最悪ケース**: \( O(n^2) \)  
  ピボットの選び方が悪く、すべての要素が一方に偏る場合。
- **平均ケース**: \( O(n \log n) \)  
  分割が均等に行われる場合。
- **最良ケース**: \( O(n \log n) \)  
  常に分割が均等で、再帰の深さが最小の場合。

---

## 5. マージソート (Merge Sort)

### **問題**
配列を昇順にソートする。

### **アルゴリズム**
1. 配列を半分に分割。
2. 各部分を再帰的にソート。
3. 分割された部分をマージ（結合）して、1つのソート済み配列にする。

### **計算量**
- **最悪ケース**: \( O(n \log n) \)  
  分割には \( O(\log n) \) のステップが必要で、各ステップでマージが \( O(n) \)。
- **最良ケース**: \( O(n \log n) \)  
  常に均等に分割される場合。