# 解説と計算量のまとめ

## 1. 線形探索 (Linear Search)

### **問題**
配列内の指定された要素を探し、そのインデックスを返す。見つからない場合は `-1` を返す。

### **アルゴリズム**
1. 配列を左から右に順番に探索。
2. 要素が見つかったら、その位置を返す。

### **計算量**
- **最悪ケース**: \( O(n) \)  
  配列全体を調べる必要がある。
- **最良ケース**: \( O(1) \)  
  最初の位置にターゲットがある場合。

---

## 2. 二分探索 (Binary Search)

### **問題**
ソート済みの配列内で指定された要素を探し、そのインデックスを返す。見つからない場合は `-1` を返す。

### **アルゴリズム**
1. 配列の中央の要素を比較。
2. ターゲットが中央より小さい場合は左側、そうでない場合は右側を再帰的または反復的に探索。

### **計算量**
- **最悪ケース**: \( O(\log n) \)  
  配列のサイズを半分に分割するため。
- **最良ケース**: \( O(1) \)  
  中央にターゲットがある場合。

---

## 3. バブルソート (Bubble Sort)

### **問題**
配列を昇順にソートする。

### **アルゴリズム**
1. 隣接する要素を比較し、必要に応じて交換。
2. 配列全体を通して交換が発生しなくなるまで繰り返す。

### **計算量**
- **最悪ケース**: \( O(n^2) \)  
  配列が逆順の場合、全ての要素を何度も比較・交換する必要がある。
- **最良ケース**: \( O(n) \)  
  配列がすでにソート済みの場合。

---

## 4. 挿入ソート (Insertion Sort)

### **問題**
配列を昇順にソートする。

### **アルゴリズム**
1. 配列を左から順に取り出し、ソート済み部分に挿入。
2. 挿入位置を決定するためにソート済み部分を逆方向に走査。

### **計算量**
- **最悪ケース**: \( O(n^2) \)  
  配列が逆順の場合、すべての要素を比較・シフトする必要がある。
- **最良ケース**: \( O(n) \)  
  配列がすでにソート済みの場合。

---

## 5. 選択ソート (Selection Sort)

### **問題**
配列を昇順にソートする。

### **アルゴリズム**
1. 未ソート部分から最小値を見つけ、ソート済み部分の末尾と交換。
2. 未ソート部分を縮小しながら繰り返す。

### **計算量**
- **最悪ケース**: \( O(n^2) \)  
  各要素に対して残りのすべての要素を比較する必要がある。
- **最良ケース**: \( O(n^2) \)  
  配列の順序に関わらず、すべての要素を比較する必要がある。

---

## 6. クイックソート (Quick Sort)

### **問題**
配列を昇順にソートする。

### **アルゴリズム**
1. 配列の中から1つの要素をピボットとして選ぶ。
2. ピボットより小さい要素を左、大きい要素を右に分ける。
3. 左右の部分を再帰的にソート。
4. 最終的にピボットと左右のソート済み部分を結合する。

### **計算量**
- **最悪ケース**: \( O(n^2) \)  
  ピボットの選び方が悪く、すべての要素が一方に偏る場合。
- **平均ケース**: \( O(n \log n) \)  
  分割が均等に行われる場合。
- **最良ケース**: \( O(n \log n) \)  
  常に分割が均等で、再帰の深さが最小の場合。

---

## 7. マージソート (Merge Sort)

### **問題**
配列を昇順にソートする。

### **アルゴリズム**
1. 配列を半分に分割。
2. 各部分を再帰的にソート。
3. 分割された部分をマージ（結合）して、1つのソート済み配列にする。

### **計算量**
- **最悪ケース**: \( O(n \log n) \)  
  分割には \( O(\log n) \) のステップが必要で、各ステップでマージが \( O(n) \)。
- **最良ケース**: \( O(n \log n) \)  
  常に均等に分割される場合。


## 8. 配列の反転

### **問題**
配列を逆順にする。

### **アルゴリズム**
1. 配列の左右から対応する要素を交換。
2. 配列の中央に到達したら終了。

### **計算量**
- **最悪ケース**: \( O(n) \)  
  配列の全要素を1回ずつ交換。

---

## 9. 回文判定 (Palindrome Check)

### **問題**
文字列が回文かどうかを判定する。

### **アルゴリズム**
1. 文字列を小文字に変換し、英数字以外の文字を除去。
2. 残った文字列を左右から比較。

### **計算量**
- **最悪ケース**: \( O(n) \)  
  フィルタリングと比較操作がそれぞれ \( O(n) \)。
