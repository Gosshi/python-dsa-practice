# 二分木の最大深さを計算する問題

## **問題概要**
二分木が与えられたとき、その最大深さ（ルートノードから最も深いリーフノードまでの距離）を計算する関数を実装します。

---

## **解法**

この問題には以下の2つの解法があります：
1. 再帰（DFS: 深さ優先探索）を使う方法
2. BFS（幅優先探索）を使う方法

---

### **1. 再帰（DFS: 深さ優先探索）**

#### **基本的な考え方**
- 再帰を使って左右の部分木の最大深さを計算します。
- 現在のノードの深さは、左右部分木の深さの **最大値に `1` を足した値** です。
- 再帰の終了条件は、ノードが `None` の場合で、このとき深さは `0` とします。

#### **アルゴリズム**
1. ベースケース：
   - ノードが空の場合（`None`）、深さ `0` を返します。
2. 再帰呼び出し：
   - 左部分木と右部分木の深さをそれぞれ計算します。
3. 結果を計算：
   - 左右部分木の深さの最大値に `1` を足して返します。

#### **Pythonコード**
```python
def max_depth_with_recursive(root: TreeNode) -> int:
    if root is None:
        return 0

    left_depth = max_depth_with_recursive(root.left)
    right_depth = max_depth_with_recursive(root.right)
    return max(left_depth, right_depth) + 1
```

---
### **2. BFS（幅優先探索）を使った二分木の最大深さ計算**

#### **基本的な考え方**
- BFS（幅優先探索）を使うことで、二分木を「レベル（層）」ごとに探索し、そのレベル数を最大深さとして計算します。
- キュー（FIFOデータ構造）を用いて、探索するノードを順番に管理します。

---

#### **アルゴリズムの流れ**

1. **初期化**
   - キューを作成し、ルートノードを最初に追加します。
   - 深さ（`depth`）を `0` に初期化します。

2. **レベル単位の処理**
   - 現在のキューのサイズ（＝現在のレベルに含まれるノードの数）を取得します。
   - キューからノードを取り出し、その子ノード（左・右）をキューに追加します。
   - 現在のレベルがすべて処理されたら、深さを `1` 増やします。

3. **終了条件**
   - キューが空になった時点で、深さを返します。

---

#### **Pythonコード**

```python
from collections import deque

def max_depth_with_bfs(root: TreeNode) -> int:
    """
    二分木の最大深さを計算する関数（BFSを使用）。

    Args:
    root (TreeNode): 二分木のルートノード

    Returns:
    int: 二分木の最大深さ
    """
    if root is None:
        return 0

    queue = deque([root])  # 初期化：ルートノードをキューに追加
    depth = 0

    while queue:
        current_level = len(queue)  # 現在のレベルに含まれるノード数
        for _ in range(current_level):
            node = queue.popleft()  # キューの先頭からノードを取り出す
```
